import { defineStore } from 'pinia'
import axios from "axios"
import { useUserStore  } from './user'
import { format, parseISO } from 'date-fns'

// You can name the return value of `defineStore()` anything you want,
// but it's best to use the name of the store and surround it with `use`
// and `Store` (e.g. `useUserStore`, `useCartStore`, `useProductStore`)
// the first argument is a unique id of the store across your application
export const useChoreStore = defineStore('chore', {
  state: () => ({ 
    areas: [],
    chores: [],
    users: [],
    historyitems: [],
    weeklytotals: [],
    units: ['day(s)', 'week(s)', 'month(s)', 'year(s)'],
    intervals: [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31],
    dayfilter: [
      {
        name: 'All',
        days: -99,
      },
      {
        name: 'Due Today',
        days: 0,
      },
      {
        name: 'Due Tomorrow',
        days: 1,
      },
      {
        name: 'Due within 3 Days',
        days: 3,
      },
      {
        name: 'Due within 1 Week',
        days: 7,
      },
    ],
    areafilter: [],
    assigneefilter: [],
    areaicons: [
      'mdi-fridge',
      'mdi-stove',
      'mdi-faucet',
      'mdi-toilet',
      'mdi-paper-roll',
      'mdi-sofa',
      'mdi-television',
      'mdi-table-chair',
      'mdi-table-furniture',
      'mdi-bed',
      'mdi-dresser',
      'mdi-cradle',
      'mdi-teddy-bear',
      'mdi-desk',
      'mdi-desk-lamp',
      'mdi-table-picnic',
      'mdi-car-back',
      'mdi-tree',
      'mdi-tumble-dryer',
      'mdi-washing-machine',
    ],
    med_thresh: 0,
    high_thresh: 10,
    vacation_mode: false,
  }),
    getters: {
      getAreas(state){
        state.areas.forEach((area) => {
        if (area.dirtiness <= state.med_thresh ) {
          area.dirtycolor = 'success'
        }else if (area.dirtiness > state.med_thresh && area.dirtiness <= state.high_thresh){
          area.dirtycolor = 'warning'
        }else if (area.dirtiness > state.high_thresh){
          area.dirtycolor = 'error'
        }
      })

        return state.areas
      },
      getAreaFilter(state){
        const areafilter = []
        state.areas.forEach((area) => {
          const temp = {}
          temp.name = area.area_name
          temp.key = area.area_name
          areafilter.push(temp)
        })
        const tempall = {
          name: 'All',
          key: 'All',
        }
        areafilter.unshift(tempall)
        return areafilter
      },
      getAssigneeFilter(state){
        const assigneefilter = []
        state.users.forEach((user) => {
          const temp = {}
          temp.fullname = user.fullname
          temp.value = user.id
          assigneefilter.push(temp)
        })
        const tempall = {
          fullname: 'All',
          value: 0
        }
        assigneefilter.unshift(tempall)
        return assigneefilter
      },
      getDayFilter(state){
        return state.dayfilter
      },
      getFilteredChores: (state) => (area, days, assignee, showDisabled) => {
        let tempChores = state.chores
        
        if (showDisabled == false) {
          tempChores = tempChores.filter((chore) => {
            return (chore.active == true)
          })
        }

        if (area != 'All' && area) {
          tempChores = tempChores.filter((chore) => {
            return (chore.area.area_name == area)
          })
        }

        const filterAssignees = (item) => {
          if (!item.assignee) {
            return false;
          } else {
            if (item.assignee.id == assignee){
              return true;
            } else {
              return false;
            }
          }
        }
        
        if (days != -99 && days != null) {
          tempChores = tempChores.filter((chore) => {
            return (chore.duedays <= days)
          })
        }

        if (assignee != 0 && assignee) {
          tempChores = tempChores.filter(filterAssignees);
        }

        tempChores.forEach((chore) => {
          chore.repeat = chore.intervalNumber + " " + chore.unit
          if (chore.assignee) {
            chore.isAssigned = true
          } else {
            chore.isAssigned = false
          }
          if (chore.duedays < 0) {
            chore.isOverdue = true
          }else{
            chore.isOverdue = false
          }
          if (chore.dirtiness <= state.med_thresh ) {
            chore.dirtycolor = 'success'
          }else if (chore.dirtiness > state.med_thresh && chore.dirtiness <= state.high_thresh){
            chore.dirtycolor = 'warning'
          }else if (chore.dirtiness > state.high_thresh){
            chore.dirtycolor = 'error'
          }
        })

        return tempChores;
      },
      getChores(state){
        state.chores.forEach((chore) => {
          chore.repeat = chore.intervalNumber + " " + chore.unit
          if (chore.assignee) {
            chore.isAssigned = true
          } else {
            chore.isAssigned = false
          }
          if (chore.duedays < 0) {
            chore.isOverdue = true
          }else{
            chore.isOverdue = false
          }
          if (chore.dirtiness <= state.med_thresh ) {
            chore.dirtycolor = 'success'
          }else if (chore.dirtiness > state.med_thresh && chore.dirtiness <= state.high_thresh){
            chore.dirtycolor = 'warning'
          }else if (chore.dirtiness > state.high_thresh){
            chore.dirtycolor = 'error'
          }
        })

        return state.chores
      },
      getUsers(state){
        return state.users
      },
      getHistoryItems(state){
        return state.historyitems
      },
      getWeeklyTotals(state){
        return state.weeklytotals
      },
      getHighThresh(state){
        return state.high_thresh
      },
      getMedThresh(state){
        return state.med_thresh
      },
      getVacationMode(state){
        return state.vacation_mode
      },
    },
    actions: {
      async fetchAll() {
        try {
          this.fetchAreas()
          this.fetchChores()
          this.fetchHistoryItems()
          this.fetchUsers()
          this.fetchWeeklyTotals()
          this.fetchOptions()
        }
        catch (error) {
          alert(error)
          console.log(error)
        }
      },
      async fetchAreas() {
        try {
          const data = await axios.get('/api/areas/')
          this.areas = data.data
        }
        catch (error) {
          alert(error)
          console.log(error)
        }
      },
      async fetchChores() {
        try {
          const data = await axios.get('/api/chores/')
          this.chores = data.data
        }
        catch (error) {
          alert(error)
          console.log(error)
        }
      },
      async fetchWeeklyTotals() {
        try {
          const data = await axios.get('/api/historyitems/weekly_totals/')
          this.weeklytotals = data.data
        }
        catch (error) {
          alert(error)
          console.log(error)
        }
      },
      async fetchUsers() {
        try {
          const data = await axios.get('/api/users/')
          this.users = data.data
        }
        catch (error) {
          alert(error)
          console.log(error)
        }
      },
      async fetchHistoryItems() {
        try {
          const data = await axios.get('/api/historyitems/')
          this.historyitems = data.data
        }
        catch (error) {
          alert(error)
          console.log(error)
        }
      },
      async fetchOptions() {
        try {
          const data = await axios.get('/api/options/')
          this.vacation_mode = data.data[0].vacation_mode
          this.med_thresh = data.data[0].med_thresh
          this.high_thresh = data.data[0].high_thresh
        }
        catch (error) {
          alert(error)
          console.log(error)
        }
      },
      async addHistoryItem(chore) {
        const userstore = useUserStore();
        const data = {
          chore_id: chore.id,
          completed_by_id: userstore.id
        }
        
        try {
          // Make a POST request to your API endpoint
          const response = await axios.post('/api/historyitem-create/', data);

          // Add area to local storage
          //this.areas.push(area);
          this.fetchHistoryItems();
          this.fetchWeeklyTotals();

        } catch (error) {
          // Handle errors (e.g., show an error message)
          console.log('Error:', error);
        }
      },
      async addArea(area) {
        try {
          // Make a POST request to your API endpoint
          const response = await axios.post('/api/areas/', area);

          // Add area to local storage
          //this.areas.push(area);
          this.fetchAreas();

        } catch (error) {
          // Handle errors (e.g., show an error message)
          console.log('Error:', error);
        }
      },
      async editArea(area) {
        try {
          // Make a POST request to your API endpoint
          const response = await axios.patch('/api/areas/' + area.id + '/', area);

          // Add area to local storage
          //this.areas.push(area);
          this.fetchAreas();
          this.fetchChores();

        } catch (error) {
          // Handle errors (e.g., show an error message)
          console.log('Error:', error);
        }
      },
      async addChore(chore) {
        try {
          // Make a POST request to your API endpoint
          
          const newDate = new Date()
          const today = new Date()
          if ( chore.unit == 'day(s)' ){
            newDate.setDate(today.getDate()+chore.intervalNumber)
          } else if ( chore.unit == 'week(s)' ){
            newDate.setDate(today.getDate()+(chore.intervalNumber*7))
          } else if ( chore.unit == 'month(s)' ){
            newDate.setMonth(today.getMonth()+chore.intervalNumber)
          } else if ( chore.unit == 'year(s)' ){
            newDate.setFullYear(today.getFullYear()+chore.intervalNumber)
          }
          
          chore.nextDue = newDate.toISOString().split('T')[0]
          const response = await axios.post('/api/chores/', chore);
          // Add area to local storage
          //this.chores.push(chore);
          this.fetchChores();
          this.fetchAreas();

        } catch (error) {
          // Handle errors (e.g., show an error message)
          console.log('Error:', error);
        }
      },
      async claimChore(chore,user) {

        const data = {
          "assignee": { 'id': ''}
        }
        if (chore.assignee){
          data.assignee = null
        } else {
          data.assignee.id = user
        }

        try {
          // Make a POST request to your API endpoint
          const response = await axios.patch('/api/chores/' + chore.id +'/', data);

          // Add area to local storage
          //this.areas.push(area);
          this.fetchChores();

        } catch (error) {
          // Handle errors (e.g., show an error message)
          console.log('Error:', error);
        }
      },
      async completeChore(chore) {

        try {
          // Make a POST request to your API endpoint
          const response = await axios.patch('/api/chore-complete/' + chore.id +'/');

          // Add area to local storage
          //this.areas.push(area);
          this.addHistoryItem(chore);
          this.fetchChores();
          this.fetchAreas();

        } catch (error) {
          // Handle errors (e.g., show an error message)
          console.log('Error:', error);
        }
      },
      async disableVacationMode() {

        try {
          // Make a POST request to your API endpoint
          const response = await axios.post('/api/options/disable_vacation_mode/');

          // Add area to local storage
          //this.areas.push(area);
          this.fetchAll();

        } catch (error) {
          // Handle errors (e.g., show an error message)
          console.log('Error:', error);
        }
      },
      async enableVacationMode() {

        try {
          // Make a POST request to your API endpoint
          const response = await axios.post('/api/options/enable_vacation_mode/');

          // Add area to local storage
          //this.areas.push(area);
          this.fetchAll();

        } catch (error) {
          // Handle errors (e.g., show an error message)
          console.log('Error:', error);
        }
      },
      async snoozeChore(chore) {
        const data = {}

        data.next_due_date = format(parseISO(chore.nextDue), 'yyyy-MM-dd')
        
        try {
          // Make a POST request to your API endpoint
          const response = await axios.patch('/api/chore-snooze/' + chore.id +'/', data);

          // Add area to local storage
          //this.areas.push(area);
          this.fetchChores();

        } catch (error) {
          // Handle errors (e.g., show an error message)
          console.log('Error:', error);
        }
      },
      async toggleChore(chore) {

        const data = {
          "active": ''
        }
        if (chore.active == false){
          data.active = true
        } else {
          data.active = false
        }

        try {
          // Make a POST request to your API endpoint
          const response = await axios.patch('/api/chores/' + chore.id +'/', data);

          // Add area to local storage
          //this.areas.push(area);
          this.fetchChores();

        } catch (error) {
          // Handle errors (e.g., show an error message)
          console.log('Error:', error);
        }
      },
      async saveChore(chore) {
        try {

          chore.nextDue = format(parseISO(chore.nextDue), 'yyyy-MM-dd')
          chore.lastCompleted = format(parseISO(chore.lastCompleted), 'yyyy-MM-dd')

          if ('dirtiness' in chore) {
            delete chore['dirtiness']
          }
          if ('duedays' in chore) {
            delete chore['duedays']
          }
          if ('last_three_history_items' in chore) {
            delete chore['last_three_history_items']
          }
          if ('assignee' in chore) {
            delete chore['assignee']
          }
          chore.expand = false
          // Make a POST request to your API endpoint
          const response = await axios.patch('/api/chores/' + chore.id + '/', chore);

          // Add area to local storage
          //this.areas.push(area);
          
          this.fetchAreas();
          this.fetchHistoryItems();
          this.fetchWeeklyTotals();
          this.fetchChores();

        } catch (error) {
        // Handle errors (e.g., show an error message)
        console.log('Error:', error);
        }
      },
      async saveOptions(med_thresh, high_thresh) {
        try {

          const data = {
              "med_thresh": med_thresh,
              "high_thresh": high_thresh,
            }

          // Make a POST request to your API endpoint
          const response = await axios.patch('/api/options/1/', data);
          console.log('Options:', data)
          // Add area to local storage
          //this.areas.push(area);
          
          this.fetchAll();

        } catch (error) {
        // Handle errors (e.g., show an error message)
        console.log('Error:', error);
        }
      },
      async deleteChore(chore) {

        try {
          // Make a POST request to your API endpoint
          const response = await axios.delete('/api/chores/' + chore.id +'/');

          // Add area to local storage
          //this.areas.push(area);
          this.fetchChores();
          this.fetchAreas();
          this.fetchHistoryItems();
          this.fetchWeeklyTotals();

        } catch (error) {
          // Handle errors (e.g., show an error message)
          console.log('Error:', error);
        }
      },
      async deleteArea(area) {

        try {
          // Make a POST request to your API endpoint
          const response = await axios.delete('/api/areas/' + area.id +'/');

          // Add area to local storage
          //this.areas.push(area);
          this.fetchAreas();
          this.fetchChores();
          this.fetchHistoryItems();
          this.fetchWeeklyTotals();

        } catch (error) {
          // Handle errors (e.g., show an error message)
          console.log('Error:', error);
        }
      },
    },
    persist: true,
  })